<!DOCTYPE html>
<html lang="en-CA"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    Slash - An Unreal Engine 5 experiment | Francis Beauchamp
    
</title>

<link rel="canonical" href="http://localhost:1313/projects/slash/"/>

<meta property="og:url" content="http://localhost:1313/projects/slash/">
  <meta property="og:site_name" content="Francis Beauchamp">
  <meta property="og:title" content="Slash - An Unreal Engine 5 experiment">
  <meta property="og:description" content="Wanting to learn Unreal Engine 5, I set out to follow this course from Stephen Ulibarri which covers a lot of topics. I ended up falling into many rabbit holes, adding many little details that were not covered by the lectures.">
  <meta property="og:locale" content="en_CA">
  <meta property="og:type" content="article">
    <meta property="article:section" content="projects">
    <meta property="article:published_time" content="2025-09-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-09-02T00:00:00+00:00">












<link rel="stylesheet" href="/assets/combined.min.749581db467d8e245e4edae1165606547d64eb179e26a7494b4352400495c34f.css" media="all">











    




</head>







<body class="light">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">Francis Beauchamp</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/projects" >
                /projects
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/projects/">Projects</a><span class="breadcrumbs-separator">/</span>
        <a href="/projects/slash/">Slash - An Unreal Engine 5 experiment</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">Slash - An Unreal Engine 5 experiment</h1>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-09-02T00:00:00&#43;00:00">September 2, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <p>Wanting to learn Unreal Engine 5, I set out to follow <a href="https://www.udemy.com/course/unreal-engine-5-the-ultimate-game-developer-course/">this course</a> from Stephen Ulibarri which covers a lot of topics. I ended up falling into many rabbit holes, adding many little details that were not covered by the lectures.</p>
<h2 class="heading" id="main-menu">
  Main menu
  <a class="anchor" href="#main-menu">#</a>
</h2>
<h3 class="heading" id="loading-a-level">
  Loading a level
  <a class="anchor" href="#loading-a-level">#</a>
</h3>
<p>One of the first things I wanted to add was a nice-looking main menu to drive the navigation betweem various states of the game. My first naive approach was to simply call <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Kismet/UGameplayStatics/OpenLevel">openLevel</a> from my blueprints. However, it has the unpleasant side effect of creating stutters in the game. The way <code>openLevel</code> function works explain why that happens in the first place. First, it synchronously unloads the entire level you&rsquo;re in; then, it will load the new one and only once all of that is completed will the game resume, resulting in a suboptimal experience.</p>
<h3 class="heading" id="stream-levels">
  Stream levels
  <a class="anchor" href="#stream-levels">#</a>
</h3>
<p>Little did I know that Unreal has a nice way to <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/level-streaming-overview-in-unreal-engine?application_version=5.4/">load stream levels</a>, a better way to load partial (or even entire) levels. In order to make that happen, we must first create a <strong>persistent</strong> level that contains all of the sub-levels we want to load/unload asynchronously. The advantage of that approach is that we free up a lot of memory dynamically as we progress between the different areas of our game. AAA titles often implement what is commonly called a <strong>loading corridor</strong>. They serve the purpose of a buffer zone where an async memory management routine is triggered. That usually involves loading the next area and freeing up resources from the past section. On my end, the way I manage such transitions is a 3-way process that involves a loading screen:</p>
<ol>
<li>Present a loading <code>BlueprintWidget</code> and keep a local reference to it.</li>
<li>Unload the current stream level and start loading the new stream level.</li>
<li>Remove the loading screen and immediately present the newly loaded level.</li>
</ol>
 <iframe src="https://blueprintue.com/render/24k7izlr/" frameborder="0" scrolling="no" width="100%" height="500px" allowfullscreen></iframe>
<p class="image-caption">This blueprint is added to the <code>GameMode</code> and handles the 3-way loading processed.</p>
<h3 class="heading" id="see-it-in-action">
  See it in action
  <a class="anchor" href="#see-it-in-action">#</a>
</h3>
<p>This short video presents the main menu level and how it transitions to the game with a loading screen without interruptions in the audio channel.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/TTqH0b_3_Uk?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<h2 class="heading" id="character-interactions">
  Character interactions
  <a class="anchor" href="#character-interactions">#</a>
</h2>
<p>The main characters can interact with the environment in several ways; I&rsquo;m going to present a few of them which I found interesting.</p>
<h3 class="heading" id="text-dispensers">
  Text dispensers
  <a class="anchor" href="#text-dispensers">#</a>
</h3>
<p>To convey simple messages to the player, I&rsquo;ve added text dispenser actors, which can be configured by setting their <code>text</code> value. When the character overlaps with the sphere component of these dispensers, they will start typing the <code>text</code>, one letter at a time, producing a randomized typing machine sound for each letter. Upon leaving the sphere&rsquo;s radius, the message will animate the scale and alpha value to zero before removing it from the game. We can set the dispenser so it only displays the message a fixed number of times (once would have a value of <code>1</code>).</p>
<h3 class="heading" id="weapons">
  Weapons
  <a class="anchor" href="#weapons">#</a>
</h3>
<p>The weapons and combat system have a lot going on, but most of it was covered by Stephen&rsquo;s class. I&rsquo;ll focus on the extra features I&rsquo;ve added that went beyond the scope of the lectures.</p>
<h4 class="heading" id="attack-chains">
  Attack chains
  <a class="anchor" href="#attack-chains">#</a>
</h4>
<p>Instead of randomly selecting an attack, weapons have associated chains of attacks tied to them. An implementation of the interface, <code>IComboGenerator</code>, has to be created. Currently, weapons and enemies are the two actors that implement it; enemies can have several invisible weapons tied to their hands and various other hitboxes added dynamically.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff6ac1">class</span> <span style="color:#f3f99d">SLASH_API</span> IComboGenerator {
</span></span><span style="display:flex;"><span>	GENERATED_BODY()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff6ac1">public</span><span style="color:#ff6ac1">:</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> TArray<span style="color:#ff6ac1">&lt;</span>UAnimMontage<span style="color:#ff6ac1">*&gt;</span> getCombos() <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> TArray<span style="color:#ff6ac1">&lt;</span><span style="color:#9aedfe">float</span><span style="color:#ff6ac1">&gt;</span> getDamageMultipliers() <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> <span style="color:#9aedfe">float</span> <span style="color:#57c7ff">getBaseDamage</span>() <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> <span style="color:#9aedfe">void</span> <span style="color:#57c7ff">setMultiplierIndex</span>(<span style="color:#9aedfe">float</span> index) <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The <code>UComboTracker</code> is responsible to keep track of the attacks generated by an assigned combo generator. This allows to set specific moments after which the combo resets or even setup complex branching chains of attacks based on both input and time. In the animations, we send different notifies to drive the combo further into the chain. A blueprint can call the <code>BlueprintCallable</code> functions when it receives those notifies and manage the chain of attacks.</p>
<p>Specifically, <code>InitiateAttack</code> is linked to a <code>initiate()</code> call. This sets the <code>canProceed</code> variable to false until we receive another notify. <code>SaveAttack</code> marks the window from which we can proceed to the next attack in the chain and is linked to a <code>track()</code> call. If another attack is not initiated during that window of opportunity, the <code>ResetCombo</code> notify is reached and will trigger <code>reset()</code> reset the current combo index. At any point in time, the consumers of that component only need to call <code>getMontage()</code> to get the animation tied to the current combo attack.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 968; --h: 265;">
        <img loading="lazy" alt="attack-notifies" src="/projects/slash/images/attack-notifies.png" width="968" height="265">
    </div>

    
</figure>
</p>
<p class="image-caption">The notify events are time sensitive. Notably <code>ResetCombo</code> won&rsquo;t be reached if we trigger an attack after <code>SaveAttack</code>, progressing further in the chain of attacks.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#ff6ac1">class</span> <span style="color:#f3f99d">SLASH_API</span> <span style="color:#ff5c57">UComboTracker</span> : <span style="color:#ff6ac1">public</span> UActorComponent {
</span></span><span style="display:flex;"><span>	GENERATED_BODY()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff6ac1">public</span><span style="color:#ff6ac1">:</span>
</span></span><span style="display:flex;"><span>	UComboTracker();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	UFUNCTION(BlueprintCallable)
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> <span style="color:#9aedfe">void</span> initiate();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	UFUNCTION(BlueprintCallable)
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> <span style="color:#9aedfe">void</span> track();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	UFUNCTION(BlueprintCallable)
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">virtual</span> <span style="color:#9aedfe">void</span> reset();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#9aedfe">void</span> <span style="color:#57c7ff">assign</span>(IComboGenerator<span style="color:#ff6ac1">*</span> generator);
</span></span><span style="display:flex;"><span>	UAnimMontage<span style="color:#ff6ac1">*</span> <span style="color:#57c7ff">getMontage</span>();
</span></span><span style="display:flex;"><span>	uint8 <span style="color:#57c7ff">getIndex</span>();
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	UPROPERTY(VisibleInstanceOnly, BlueprintReadWrite, Category <span style="color:#ff6ac1">=</span> Combo)
</span></span><span style="display:flex;"><span>	<span style="color:#9aedfe">bool</span> canProceed <span style="color:#ff6ac1">=</span> <span style="color:#ff5c57">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff6ac1">protected</span><span style="color:#ff6ac1">:</span>
</span></span><span style="display:flex;"><span>	IComboGenerator<span style="color:#ff6ac1">*</span> comboGenerator;
</span></span><span style="display:flex;"><span>	uint8 comboIndex <span style="color:#ff6ac1">=</span> <span style="color:#ff9f43">0</span>;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h4 class="heading" id="focus-points">
  Focus points
  <a class="anchor" href="#focus-points">#</a>
</h4>
<p>The character has two movement modes he can switch between:</p>
<ol>
<li>The <strong>standard</strong> mode where he walks in a forward-facing manner, usually used to navigate in the world.</li>
<li>The <strong>focus</strong> mode, where the camera tracks a focus point on the enemies and the movements are slower and oriented toward the focus.</li>
</ol>
<p>In order to create focusable targets, I have added a socket on their heads and assigned a widget blueprint with a <strong>dot</strong> marker. This blueprint is presented in world space since it needs to move with the enemy&rsquo;s movements. The current version is very barebones in that we don&rsquo;t track focus priorities. We have a sphere on the character that adds overlapping enemies to a list; when the player triggers the focus action, we take the last valid enemy, display its focus marker and enter in the focus mode.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AMainCharacter<span style="color:#ff6ac1">::</span>focus(<span style="color:#ff6ac1">const</span> FInputActionValue<span style="color:#ff6ac1">&amp;</span> Value) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (isFocused()) {
</span></span><span style="display:flex;"><span>		focus(<span style="color:#ff6ac1">nullptr</span>);
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> <span style="color:#57c7ff">if</span> (<span style="color:#ff6ac1">!</span>focusableEnemies.IsEmpty()) {
</span></span><span style="display:flex;"><span>		AEnemy<span style="color:#ff6ac1">*</span> enemy <span style="color:#ff6ac1">=</span> focusableEnemies.Last();
</span></span><span style="display:flex;"><span>		enemy<span style="color:#ff6ac1">-&gt;</span>OnFocus();
</span></span><span style="display:flex;"><span>		focus(enemy);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The focus mode changes the way movement works for the character; we move more slowly in all directions while always facing the focused target. To get the <code>right</code> motion vector, we use the vector between the character and its target, then apply a cross product with the up vector. It results in the character following a circular motion around the focus target instead of wandering off in a straight line. To play the correct movement animation, the blueprint can use the <code>directionalSpeed</code> to blend between animations using a blend space. Finally, selecting the appropriate dodge animation to play requires the use of an <code>inputDirection</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AMainCharacter<span style="color:#ff6ac1">::</span>move(<span style="color:#ff6ac1">const</span> FInputActionValue<span style="color:#ff6ac1">&amp;</span> Value) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (actionState <span style="color:#ff6ac1">!=</span> EActionState<span style="color:#ff6ac1">::</span>EAS_unoccupied) <span style="color:#ff6ac1">return</span>;
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">const</span> FVector2D val <span style="color:#ff6ac1">=</span> Value.Get<span style="color:#ff6ac1">&lt;</span>FVector2D<span style="color:#ff6ac1">&gt;</span>();
</span></span><span style="display:flex;"><span>    directionalSpeed <span style="color:#ff6ac1">=</span> val;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (isFocused()) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">if</span> (val.X <span style="color:#ff6ac1">!=</span> <span style="color:#ff9f43">0.f</span>) {
</span></span><span style="display:flex;"><span>			inputDirection <span style="color:#ff6ac1">=</span> val.X <span style="color:#ff6ac1">&gt;</span> <span style="color:#ff9f43">0</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ff6ac1">?</span> EInputDirection<span style="color:#ff6ac1">::</span><span style="color:#ff5c57">EID_right</span>
</span></span><span style="display:flex;"><span>				: EInputDirection<span style="color:#ff6ac1">::</span>EID_left;
</span></span><span style="display:flex;"><span>			FVector right <span style="color:#ff6ac1">=</span> <span style="color:#ff6ac1">-</span>focusVector.Cross(FVector<span style="color:#ff6ac1">::</span>UnitZ());
</span></span><span style="display:flex;"><span>			AddMovementInput(right, val.X);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">if</span> (val.Y <span style="color:#ff6ac1">!=</span> <span style="color:#ff9f43">0.f</span>) {
</span></span><span style="display:flex;"><span>			inputDirection <span style="color:#ff6ac1">=</span> val.Y <span style="color:#ff6ac1">&gt;</span> <span style="color:#ff9f43">0</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ff6ac1">?</span> EInputDirection<span style="color:#ff6ac1">::</span><span style="color:#ff5c57">EID_forward</span>
</span></span><span style="display:flex;"><span>				: EInputDirection<span style="color:#ff6ac1">::</span>EID_backward;
</span></span><span style="display:flex;"><span>			AddMovementInput(focusVector, val.Y);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">const</span> FRotator rotation <span style="color:#ff6ac1">=</span> GetControlRotation();
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">const</span> FRotator yaw <span style="color:#ff6ac1">=</span> FRotator(<span style="color:#ff9f43">0.f</span>, rotation.Yaw, <span style="color:#ff9f43">0.f</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">const</span> FRotationMatrix M <span style="color:#ff6ac1">=</span> FRotationMatrix(yaw);
</span></span><span style="display:flex;"><span>		inputDirection <span style="color:#ff6ac1">=</span> EInputDirection<span style="color:#ff6ac1">::</span>EID_forward;
</span></span><span style="display:flex;"><span>		AddMovementInput(M.GetUnitAxis((EAxis<span style="color:#ff6ac1">::</span>X)), val.Y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		AddMovementInput(M.GetUnitAxis((EAxis<span style="color:#ff6ac1">::</span>Y)), val.X);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 class="heading" id="destructibles">
  Destructibles
  <a class="anchor" href="#destructibles">#</a>
</h3>
<p>Some actors can be destroyed because they&rsquo;ve been converted to mesh collection. These meshes are fragmented in several parts which are held together by a force. Granted that we apply enough counterforce on the mesh, it will fall apart and the pieces will be thrown in various directions. One of the ways we do this in Unreal Engine is by applying a strain at a point of impact, then we give them a linear motion with a physics field.</p>
 <iframe src="https://blueprintue.com/render/dcx601b3/" frameborder="0" scrolling="no" width="100%" height="500px" allowfullscreen></iframe>
<p class="image-caption">This blueprint illustrates the creation of a physics force that breaks destructible meshes.</p>
<h3 class="heading" id="see-it-in-action-1">
  See it in action
  <a class="anchor" href="#see-it-in-action-1">#</a>
</h3>
<p>This short video presents the different character features that were introduced in this section.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/j_yeXZJId94?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<h2 class="heading" id="dynamic-footsteps">
  Dynamic footsteps
  <a class="anchor" href="#dynamic-footsteps">#</a>
</h2>
<p>One of the instances where I went down a rabbit hole was by adding dynamic footsteps that would produce different sounds based on the surface the feet interact with. My approach is quite simple: assign physical materials to my textures and objects, give the materials their associated sound and play them instead of a fixed sound baked in the animation.</p>
<p>We start by creating a data asset containing the mappings of physical material and their associated sounds. We can decide to use raw wave assets, audio cues or metasounds. I have opted for metasounds because they allow better customization. Each <code>sfx</code> instance has a metasound blueprints which includes some randomization logic. We set up the values for the different footstep audios and shuffle them before playing the chosen sound with a random volume and pitch variation.</p>
 <iframe src="https://blueprintue.com/render/p5490m5o/" frameborder="0" scrolling="no" width="100%" height="500px" allowfullscreen></iframe>
<p class="image-caption">This blueprint illustrates the randomization process that creates a sound that feels less repetitive.</p>
<p>Once we have finished with the mappings, we need a way to trigger custom notifies in our animations whenever a foot touches the ground. The naive approach is simply play the audio here, but it doesn&rsquo;t allow us to change the sound based on the surfaces. In my case, the <code>PlaySound</code> notify is changed for a custom blueprint class called <code>BP_Footstep</code>.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 896; --h: 221;">
        <img loading="lazy" alt="footstep-notify" src="/projects/slash/images/footstep-notify.png" width="896" height="221">
    </div>

    
</figure>
</p>
<p class="image-caption">Whenever a foot hits the ground in the animation, the custom <code>BP_Footstep</code> notify is triggered.</p>
<p>In that blueprint, two things happen:</p>
<ol>
<li>A line trace from a point slightly above the character&rsquo;s location. When it succeeds, we get a hit result that will have an associated physical material (make sure to set up the <code>default</code> mapping as a fallback).</li>
<li>Find the physical material in our data asset and play the sound associated with it.</li>
</ol>
 <iframe src="https://blueprintue.com/render/_nc32jrx/" frameborder="0" scrolling="no" width="100%" height="500px" allowfullscreen></iframe>
<p class="image-caption">This blueprint illustrates the line trace and selection of an appropriate audio.</p>
<h3 class="heading" id="see-it-in-action-2">
  See it in action
  <a class="anchor" href="#see-it-in-action-2">#</a>
</h3>
<p>This short video presents the different footstep sounds implemented in my game.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/W0g5dt6lyRA?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>

<h2 class="heading" id="enemy-ai">
  Enemy AI
  <a class="anchor" href="#enemy-ai">#</a>
</h2>
<p>The enemy AI was not built using decisions tree, but by keeping track of the different states in c++. I became very quickly apparent how my approach would become problematic as I started adding more behaviour variations to my enemies. On top of that, Stephen&rsquo;s class proposes to build these features within a reusable <code>Enemy</code> class which leads to a very large amount of code in the same pace. I have opted to create a custom <code>aiController</code> class that can be assigned to my enemies. If I want to create a completely different type of behaviour, I simply need to implement a new <code>aiController</code>.</p>
<p>To react to the player&rsquo;s presence, I use the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/ai-perception-in-unreal-engine">AIPerceptionComponent</a> with a configured sight sense. This allows my enemies to react to the player&rsquo;s presence whenever it enters their field of sight. Whenever that happens, and depending on the distance between an enemy and the player, different states will be reached and change the way it behaves.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 1424; --h: 760;">
        <img loading="lazy" alt="enemy-states" src="/projects/slash/images/enemy-states.png" width="1424" height="760">
    </div>

    
</figure>
</p>
<p class="image-caption">The enemy begins in a patrolling state. From there, the distance with the player will make it switch between the various other states that define how it will behave.</p>
<p>Most important perhaps is the tick function which runs patrol or combat updates depending on the current state. For instance, if the player dies, the enemy will stop chasing after it and be brought back to the patrolling state.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AEnemyAiController<span style="color:#ff6ac1">::</span>Tick(<span style="color:#9aedfe">float</span> DeltaTime) {
</span></span><span style="display:flex;"><span>	Super<span style="color:#ff6ac1">::</span>Tick(DeltaTime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (isDead()) <span style="color:#ff6ac1">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget <span style="color:#ff6ac1">&amp;&amp;</span> aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget<span style="color:#ff6ac1">-&gt;</span>ActorHasTag(ABaseCharacter<span style="color:#ff6ac1">::</span>DEAD_CHARACTER_TAG)) {
</span></span><span style="display:flex;"><span>		aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget <span style="color:#ff6ac1">=</span> <span style="color:#ff6ac1">nullptr</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (isEngaged() <span style="color:#ff6ac1">&amp;&amp;</span> withinCombatRadius()) {
</span></span><span style="display:flex;"><span>		faceTarget(aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget, DeltaTime, <span style="color:#ff9f43">3.5f</span>);
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> <span style="color:#57c7ff">if</span> (isPatrolling()) {
</span></span><span style="display:flex;"><span>		updatePatrolTarget();
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> {
</span></span><span style="display:flex;"><span>		updateCombatTarget();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Setting up the perception of a player and moving between states is as simple as implementing one function. Whenever our configured sight stimulus is active, we start chasing the seen player.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AEnemyAiController<span style="color:#ff6ac1">::</span>onPerceptionUpdated(AActor<span style="color:#ff6ac1">*</span> Actor, FAIStimulus Stimulus) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (isDead() <span style="color:#ff6ac1">||</span> isChasing() <span style="color:#ff6ac1">||</span> isEngaged()) <span style="color:#ff6ac1">return</span>;
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (Stimulus.Type <span style="color:#ff6ac1">==</span> UAISense<span style="color:#ff6ac1">::</span>GetSenseID<span style="color:#ff6ac1">&lt;</span>UAISense_Sight<span style="color:#ff6ac1">&gt;</span>()) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">if</span> (Stimulus.IsActive()) {
</span></span><span style="display:flex;"><span>			<span style="color:#ff6ac1">if</span> (shouldChaseTarget(Actor)) {
</span></span><span style="display:flex;"><span>				startChasing(Actor);
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		} <span style="color:#ff6ac1">else</span> <span style="color:#57c7ff">if</span> (Stimulus.IsExpired()) {
</span></span><span style="display:flex;"><span>			startPatrolling();
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order to better track the player during attacks, we slowly update orientation at a given speed during the animation. This prevents attacks from making the enemy rooted in place and always missing when the player is currently moving.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AEnemyAiController<span style="color:#ff6ac1">::</span>faceTarget(AActor<span style="color:#ff6ac1">*</span> target, <span style="color:#9aedfe">float</span> dt, <span style="color:#9aedfe">float</span> speed) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">const</span> FRotator lookat <span style="color:#ff6ac1">=</span> UKismetMathLibrary<span style="color:#ff6ac1">::</span>FindLookAtRotation(
</span></span><span style="display:flex;"><span>        enemy<span style="color:#ff6ac1">-&gt;</span>GetActorLocation(), 
</span></span><span style="display:flex;"><span>        target<span style="color:#ff6ac1">-&gt;</span>GetActorLocation()
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">const</span> FRotator interp <span style="color:#ff6ac1">=</span> FMath<span style="color:#ff6ac1">::</span>RInterpTo(enemy<span style="color:#ff6ac1">-&gt;</span>GetActorRotation(), lookat, dt, speed);
</span></span><span style="display:flex;"><span>	enemy<span style="color:#ff6ac1">-&gt;</span>SetActorRotation(interp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When in the patrolling state, we wait for random period of time at the patrol targets and then randomly select a new one. Those targets are set within the engine for each of the enemy actors, but they could be added dynamically if we wanted.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AEnemyAiController<span style="color:#ff6ac1">::</span>updatePatrolTarget() {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (inTargetRange(aiProperties<span style="color:#ff6ac1">-&gt;</span>patrolTarget, aiProperties<span style="color:#ff6ac1">-&gt;</span>patrolRadius)) {
</span></span><span style="display:flex;"><span>		aiProperties<span style="color:#ff6ac1">-&gt;</span>patrolTarget <span style="color:#ff6ac1">=</span> selectPatrolTarget();
</span></span><span style="display:flex;"><span>		<span style="color:#ff6ac1">const</span> <span style="color:#9aedfe">float</span> rng <span style="color:#ff6ac1">=</span> FMath<span style="color:#ff6ac1">::</span>RandRange(aiProperties<span style="color:#ff6ac1">-&gt;</span>minWaitTime, aiProperties<span style="color:#ff6ac1">-&gt;</span>maxWaitTime);
</span></span><span style="display:flex;"><span>		GetWorldTimerManager().SetTimer(patrolTimer, <span style="color:#ff6ac1">this</span>, <span style="color:#ff6ac1">&amp;</span>AEnemyAiController<span style="color:#ff6ac1">::</span>patrolTimerFinished, rng);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When alerted by the player&rsquo;s presence, an enemy will either chase or attack them depending on how far away they are from one another. During an attack animation, the enemy is considered <code>Enagaged</code> and cannot do any other actions such as moving or attacking. As soon as the player reaches a &ldquo;safe distance&rdquo; the enemy will revert back to its patrol state and resume updating the patrol targets.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>AActor<span style="color:#ff6ac1">*</span> AEnemyAiController<span style="color:#ff6ac1">::</span>updateCombatTarget() {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (<span style="color:#ff6ac1">!</span>withinCombatRadius()) {
</span></span><span style="display:flex;"><span>		startPatrolling();
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> <span style="color:#57c7ff">if</span> (<span style="color:#ff6ac1">!</span>withinAttackRadius()) {
</span></span><span style="display:flex;"><span>		<span style="color:#78787e">// Outside of attack range, start chasing
</span></span></span><span style="display:flex;"><span><span style="color:#78787e"></span>		startChasing(aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget);
</span></span><span style="display:flex;"><span>	} <span style="color:#ff6ac1">else</span> <span style="color:#57c7ff">if</span> (withinAttackRadius()) {
</span></span><span style="display:flex;"><span>		startAttacking();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">return</span> aiProperties<span style="color:#ff6ac1">-&gt;</span>combatTarget;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The movement of all enemies is done with the use of <code>FAIMoveRequest</code>. We can set an acceptance radius so the movement is deemed completed a little bit before reaching the exact target (which can sometimes be hard to reach because of inaccuracy).</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#9aedfe">void</span> AEnemyAiController<span style="color:#ff6ac1">::</span>moveToTarget(AActor<span style="color:#ff6ac1">*</span> target) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff6ac1">if</span> (<span style="color:#ff6ac1">!</span>target <span style="color:#ff6ac1">||</span> isEngaged()) <span style="color:#ff6ac1">return</span>;
</span></span><span style="display:flex;"><span>	FAIMoveRequest request;
</span></span><span style="display:flex;"><span>	request.SetGoalActor(target);
</span></span><span style="display:flex;"><span>	request.SetAcceptanceRadius(aiProperties<span style="color:#ff6ac1">-&gt;</span>moveToTargetAcceptance);
</span></span><span style="display:flex;"><span>	MoveTo(request);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 class="heading" id="see-it-in-action-3">
  See it in action
  <a class="anchor" href="#see-it-in-action-3">#</a>
</h3>
<p>This short video shows some of the presented AI behaviours.</p>
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/YPqunv1iQcI?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"></iframe>
    </div>
    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
            <div class="single-pagination-container-prev">
                <div class="single-pagination-text">←</div>
                <div class="single-pagination-text">
                    <a href="/projects/swifttracer/">
                        SwiftTracer - A physically based rendering engine
                    </a>
                </div>
            </div>
            
        </div>

        <div class="single-pagination-next">
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
