<!DOCTYPE html>
<html lang="en-CA"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    SwiftTracer - A physically based rendering engine | Francis Beauchamp
    
</title>

<link rel="canonical" href="http://localhost:1313/projects/swifttracer/"/>

<meta property="og:url" content="http://localhost:1313/projects/swifttracer/">
  <meta property="og:site_name" content="Francis Beauchamp">
  <meta property="og:title" content="SwiftTracer - A physically based rendering engine">
  <meta property="og:description" content="SwiftTracer is an implementation of a physically based rendering engine that is inspired by PBRT, Mitsuba and many other contributors in the field. At it’s core, it uses simd to perform the ray tracing computations: mostly vectors and matrices operations along with some trigonometry. The tracing is done in parallel, thanks to the new async/await concurrency model introduced in Swift 5.5. We split our target image in a series of blocks, all of which run a self-contained tracing task. The collision detection is done using a combination of shape intersections, AABBs and even acceleration techniques like BVH. Several image formats like png, jpg, pfm and exr are supported.">
  <meta property="og:locale" content="en_CA">
  <meta property="og:type" content="article">
    <meta property="article:section" content="projects">
    <meta property="article:published_time" content="2025-07-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-05T00:00:00+00:00">












<link rel="stylesheet" href="/assets/combined.min.8beed8d54dde0701365f53667913f01ddfc46677839a605e04b7b284b053087b.css" media="all">











    




</head>







<body class="light">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">Francis Beauchamp</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/projects" >
                /projects
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/projects/">Projects</a><span class="breadcrumbs-separator">/</span>
        <a href="/projects/swifttracer/">SwiftTracer - A physically based rendering engine</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">SwiftTracer - A physically based rendering engine</h1>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-07-05T00:00:00&#43;00:00">July 5, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <p>SwiftTracer is an implementation of a physically based rendering engine that is inspired by PBRT, Mitsuba and many other contributors in the field. At it&rsquo;s core, it uses <a href="https://developer.apple.com/documentation/accelerate/simd-library">simd</a> to perform the ray tracing computations: mostly vectors and matrices operations along with some trigonometry. The tracing is done in parallel, thanks to the new <code>async/await</code> <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/">concurrency model</a> introduced in Swift 5.5. We split our target image in a series of blocks, all of which run a self-contained tracing task. The collision detection is done using a combination of shape intersections, AABBs and even acceleration techniques like BVH. Several image formats like png, jpg, pfm and exr are supported.</p>
<h2 class="heading" id="materials">
  Materials
  <a class="anchor" href="#materials">#</a>
</h2>
<p>There are currently 4 base materials implemented, which use their own distribution functions to support light scattering. On top of these, it is possible to blend them with a linear combination of two different materials. The strenght of the blend can be defined by an <code>alpha</code> parameter.</p>

<div class="table-outer">
    <table>
        <thead>
            <tr>
                <th style="text-align: center">Diffuse</th>
                <th style="text-align: center">Smooth metal</th>
                <th style="text-align: center">Rough metal</th>
                <th style="text-align: center">Glass</th>
                <th style="text-align: center">Blend</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="diffuse" src="/projects/swifttracer/images/diffuse.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="metal" src="/projects/swifttracer/images/metal.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="rough metal" src="/projects/swifttracer/images/metal-rough.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="glass" src="/projects/swifttracer/images/glass.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="glass" src="/projects/swifttracer/images/blend.png" width="512" height="512">
    </div>

    
</figure>
</td>
            </tr>
        </tbody>
    </table>
</div><p>There are a few geometry primitives that are supported, although meshes and triangles is what have been used the most throughout my test scenes. We also have <code>quads</code> and <code>spheres</code></p>
<p>Triangle intersection uses the <a href="https://dl.acm.org/doi/10.1145/1198555.1198746">Möller–Trumbore ray-triangle intersection algorithm</a>. Vertices and normals are currently supported. Tangents will be added at a later time when I port over anisotropic materials from my Rust implementation.</p>
<h2 class="heading" id="ray-tracing">
  Ray tracing
  <a class="anchor" href="#ray-tracing">#</a>
</h2>
<p>The rendering equation describes the propagation luminance quantity $L$ as it travels from any number of incoming and outgoing rays of light $\omega_i, \omega_o$.</p>
<p>$L_o(x, \omega_o) = L_e(x, \omega_o)+\int_{\Omega} f_v(x, \omega_i, \omega_o) L_i(x, \omega_i) (\omega_i \cdot n)\mathrm{d}\omega_i,$</p>
<p>where it&rsquo;s recursive application from surface to surface gives $F(\overline{x})$, the contribution for path $\overline{x}$. With $n$ interactions, we would have a list of $n+1$ vertices $\overline{x} = { x_0, &hellip;, x_n }$. This equation is typically solved by replacing the ingetrals with numerical methods.</p>
<p>Interactions are calculated in the local coordinate system, where both the incoming and outgoing $\omega_o, \omega_i$ directions are pointing outwards from a surface with a normal of $(0, 0, 1)$.</p>
<h3 class="heading" id="integrators">
  Integrators
  <a class="anchor" href="#integrators">#</a>
</h3>
<h3 class="heading" id="asynchronous-processing">
  Asynchronous processing
  <a class="anchor" href="#asynchronous-processing">#</a>
</h3>
<p>In order to render my scenes, I create a global task which awaits a series of block renders defined in <code>renderBlocks</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">render</span>(scene: Scene) -&gt; PixelBuffer {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">image</span> = PixelBuffer(
</span></span><span style="display:flex;"><span>        width: <span style="color:#ff5c57">Int</span>(scene.camera.resolution.x), 
</span></span><span style="display:flex;"><span>        height: <span style="color:#ff5c57">Int</span>(scene.camera.resolution.y), 
</span></span><span style="display:flex;"><span>        value: .zero
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">gcd</span> = DispatchGroup()
</span></span><span style="display:flex;"><span>    gcd.enter()
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">defer</span> { gcd.leave() }
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">blocks</span> = await renderBlocks(blockSize: <span style="color:#ff9f43">32</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> blocks.assemble(into: image)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    gcd.wait()
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> image
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The creation of the individual tasks happen in the <code>renderBlocks</code> function where they are added to the group, once per block. Depending on the resolution <code>res</code> of the resulting image and the chosen <code>blockSize</code>, there will be a varying number of spawned child processes. Their results are aggregated together using an <code>await</code> keyword, and once all rendering tasks are completed, their combined results is returned.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">renderBlocks</span>(blockSize: <span style="color:#ff5c57">Int</span>, res: Vec2) async -&gt; [Block] {
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> await withTaskGroup(of: Block.<span style="color:#ff6ac1">self</span>) { group <span style="color:#ff6ac1">in</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">for</span> x <span style="color:#ff6ac1">in</span> <span style="color:#ff5c57">stride</span>(from: <span style="color:#ff9f43">0</span>, to: res.x, by: blockSize) {
</span></span><span style="display:flex;"><span>            <span style="color:#ff6ac1">for</span> y <span style="color:#ff6ac1">in</span> <span style="color:#ff5c57">stride</span>(from: <span style="color:#ff9f43">0</span>, to: res.y, by: blockSize) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">size</span> = Vec2(
</span></span><span style="display:flex;"><span>                    <span style="color:#ff5c57">min</span>(res.x <span style="color:#ff6ac1">-</span> <span style="color:#ff5c57">Float</span>(x), <span style="color:#ff5c57">Float</span>(blockSize)),
</span></span><span style="display:flex;"><span>                    <span style="color:#ff5c57">min</span>(res.y <span style="color:#ff6ac1">-</span> <span style="color:#ff5c57">Float</span>(y), <span style="color:#ff5c57">Float</span>(blockSize))
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                group.addTask {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff6ac1">return</span> integrate(size: size, pos: Vec2(x, y))
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">blocks</span>: [Block] = []
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">for</span> await block <span style="color:#ff6ac1">in</span> group {
</span></span><span style="display:flex;"><span>            blocks.append(block)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> blocks
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>A simple rendering method that I have implemented is the <code>Path</code> integrator which uses a simple Monte-Carlo algorithm. The way it goes is that for each pixels $(x, y)$ in the block, we will cast $n$ rays of light and average their total contributions by the number of samples $n$.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">integrate</span>(size: Vec2, pos: Vec2, samples n: <span style="color:#ff5c57">Int</span>) -&gt; Block {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">img</span> = PixelBuffer(
</span></span><span style="display:flex;"><span>        width: size.x, 
</span></span><span style="display:flex;"><span>        height: size.y, 
</span></span><span style="display:flex;"><span>        value: .zero
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">block</span> = Block(position: Vec2(x, y), size: size, image: img)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">for</span> lx <span style="color:#ff6ac1">in</span> <span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.x {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">for</span> ly <span style="color:#ff6ac1">in</span> <span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.y {
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">x</span> = lx <span style="color:#ff6ac1">+</span> block.position.x
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">y</span> = ly <span style="color:#ff6ac1">+</span> block.position.y
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">avg</span> = Color()
</span></span><span style="display:flex;"><span>            <span style="color:#ff6ac1">for</span> <span style="color:#ff6ac1">_</span> <span style="color:#ff6ac1">in</span> (<span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> n) {
</span></span><span style="display:flex;"><span>                <span style="color:#78787e">// Anti aliasing</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">aaPos</span> = Vec2(x, y) <span style="color:#ff6ac1">+</span> sampler.next2()
</span></span><span style="display:flex;"><span>                <span style="color:#78787e">// Integrate the ray contribution</span>
</span></span><span style="display:flex;"><span>                avg <span style="color:#ff6ac1">+=</span> li(pixel: aaPos)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            img[lx, ly] = avg <span style="color:#ff6ac1">/</span> <span style="color:#ff5c57">Float</span>(n)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    block.image = img
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> block
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
  </article>

  

  

  
  

<div class="single-pagination">
    <hr />

    <div class="flexnowrap">

        <div class="single-pagination-prev">
            
        </div>

        <div class="single-pagination-next">
            
            <div class="single-pagination-container-next">
                <div class="single-pagination-text">
                    <a href="/projects/slash/">
                        Slash
                    </a>
                </div>
                <div class="single-pagination-text">→</div>
            </div>
            
        </div>

    </div>

    <hr />
</div>



  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
