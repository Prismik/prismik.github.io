<!DOCTYPE html>
<html lang="en-CA"
  dir="ltr">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">








    






<link rel="icon" type="image/ico" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="http://localhost:1313/android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/apple-touch-icon.png">

<meta name="description" content=""/>



<title>
    
    SwiftTracer - A physically based rendering engine | Francis Beauchamp
    
</title>

<link rel="canonical" href="http://localhost:1313/projects/swifttracer/"/>

<meta property="og:url" content="http://localhost:1313/projects/swifttracer/">
  <meta property="og:site_name" content="Francis Beauchamp">
  <meta property="og:title" content="SwiftTracer - A physically based rendering engine">
  <meta property="og:description" content="SwiftTracer is a Swift implementation of a physically based rendering engine inspired by PBRT, Mitsuba and many other contributors. It was built to support my research efforts as part of my masterâ€™s degree. The engine currently support several image formats like png, jpg, pfm and exr. See for yourself on github.">
  <meta property="og:locale" content="en_CA">
  <meta property="og:type" content="article">
    <meta property="article:section" content="projects">
    <meta property="article:published_time" content="2025-07-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-07-05T00:00:00+00:00">












<link rel="stylesheet" href="/assets/combined.min.8beed8d54dde0701365f53667913f01ddfc46677839a605e04b7b284b053087b.css" media="all">











    




</head>







<body class="light">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="http://localhost:1313/">Francis Beauchamp</a>
    </h1>

    <div class="header-menu">
        

        
        

        <p
            class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/projects" >
                /projects
            </a>
        </p>
        

        <p
            class="small ">
            <a href="/about" >
                /about
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      




<div class="breadcrumbs"><a href="/">Home</a><span class="breadcrumbs-separator">/</span><a href="/projects/">Projects</a><span class="breadcrumbs-separator">/</span>
        <a href="/projects/swifttracer/">SwiftTracer - A physically based rendering engine</a></div>


<div >
  <article>
    <header class="single-intro-container">
        
        <h1 class="single-title">SwiftTracer - A physically based rendering engine</h1>
        
        <div class="single-subsummary">
          
          <div>
            
            <p class="single-date">
              <time datetime="2025-07-05T00:00:00&#43;00:00">July 5, 2025</time>
            </p>
          </div>
        </div>
        
    </header>
    
    <div class="single-content">
      <p>SwiftTracer is a Swift implementation of a physically based rendering engine inspired by PBRT, Mitsuba and many other contributors. It was built to support my research efforts as part of my master&rsquo;s degree. The engine currently support several image formats like <code>png</code>, <code>jpg</code>, <code>pfm</code> and <code>exr</code>. See for yourself on <a href="https://github.com/Prismik/SwiftTracer">github</a>.</p>
<p>But what does &ldquo;physically based&rdquo; even mean? For one, we are interested in simulating the behaviour of light such that it respects the laws of physics. Kajiya first introduced the <a href="https://doi.org/10.1145/15886.15902">rendering equation</a> which allows us to do just that with the help of techniques such as Monte-Carlo integration. By accumulating several light paths randomly generated, we obtain an approximation of the light propagation within a scene. This approach can be used to represent complex light effects such as caustics and subsurface scattering.</p>
<h2 class="heading" id="mathematical-operations">
  Mathematical operations
  <a class="anchor" href="#mathematical-operations">#</a>
</h2>
<p>At it&rsquo;s core, SwiftTracer uses <a href="https://developer.apple.com/documentation/accelerate/simd-library">simd</a> to perform the mathematical computations: mostly vectors and matrices operations along with some trigonometry. Why does this matter? Because it turns out that ray tracing requires a lot of vector operations, both for image handling and the actual tracing. Imagine you want to sum the contributions of many images to get their average, or say, scale all of their values by a scalar. We would normally make such operations for each pixels. But since simd handles multiple data with a single instruction, it&rsquo;s a perfect fit for this kind of problem. We can store an image as a vector of scalars, and use a single instruction to apply transformation on each of it&rsquo;s elements.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 2552; --h: 844;">
        <img loading="lazy" alt="simd" src="/projects/swifttracer/images/simd.png" width="2552" height="844">
    </div>

    
</figure>
</p>
<p>While this is good enough for large number of small mutations on vectors, applying transformations to large collections rather than 2 or 3 dimentional vectors still prove to be highly inefficient. For instance, a 1024x768 image will have 786,432 RGB elements to mutate when applying uniform scaling operations. Fortunately for us, the <a href="https://developer.apple.com/documentation/accelerate">Accelerate</a> framework comes with the <a href="https://developer.apple.com/documentation/accelerate/vdsp-library">vDSP</a> module, and it is a perfect fit for our problem since it provides &ldquo;general purpose arithmetic on large collections&rdquo;. It follows the same principles as SIMD, only it is tailored to large datasets. Imagine we want to merge two images together. A naive approach would be to simply iterate over all of the pixel from the first image, get the corresponding pixel in the second image, calculate their sum and assign it to the pixel storage.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">merge</span>(with other: Image) {
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">for</span> (i, value) <span style="color:#ff6ac1">in</span> other.enumerated() {
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">current</span> = storage[i]
</span></span><span style="display:flex;"><span>        storage[i] = current <span style="color:#ff6ac1">+</span> value
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But since we know the two images store their pixels with the same number of elements ordered identically, <code>vDSP</code> allows us to make that elementwise sum much more efficient with just about the same amount of code (less even).</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">merge</span>(with other: Image) {
</span></span><span style="display:flex;"><span>    storage = vDSP.add(other.storage, <span style="color:#ff6ac1">self</span>.storage)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, this comes with a caveat, and it is that <code>vDSP</code> is much easier to setup with collections of scalar. For that reason, SwiftTracer&rsquo;s implementation of a <code>PixelBuffer</code> uses an array of <code>Float</code> instead of an array of RGB pixels. What this mean is that in order to mutate the i-th element using our expected <code>buffer[i] = value</code>, we must hide away that representation from the user.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">subscript</span>(i: <span style="color:#ff5c57">Int</span>) -&gt; Color {
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">get</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">index</span> = i <span style="color:#ff6ac1">*</span> <span style="color:#ff9f43">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> Color(storage[index], storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">1</span>], storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">2</span>])
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">set</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">index</span> = i <span style="color:#ff6ac1">*</span> <span style="color:#ff9f43">3</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">r</span> = storage[index]
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">g</span> = storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">1</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">b</span> = storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        storage[index] = newValue.x
</span></span><span style="display:flex;"><span>        storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">1</span>] = newValue.y
</span></span><span style="display:flex;"><span>        storage[index<span style="color:#ff6ac1">+</span><span style="color:#ff9f43">2</span>] = newValue.z
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 class="heading" id="parellel-processing">
  Parellel processing
  <a class="anchor" href="#parellel-processing">#</a>
</h2>
<p>Rendering a full scene can take a lot of time. To speed up the process, SwiftTracer does as much of it as it can in parallel, thanks to the new <code>async/await</code> <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/">concurrency model</a> introduced in Swift 5.5. We split our target image in a series of blocks, which run their own self-contained tracing task. First, we must decide on a block size and make an <code>assemble</code> function that will bring them back together as one image.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">render</span>(scene: Scene) -&gt; PixelBuffer {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">image</span> = PixelBuffer(
</span></span><span style="display:flex;"><span>        width: scene.camera.res.x,
</span></span><span style="display:flex;"><span>        height: scene.camera.res.y,
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">gcd</span> = DispatchGroup()
</span></span><span style="display:flex;"><span>    gcd.enter()
</span></span><span style="display:flex;"><span>    Task {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">defer</span> { gcd.leave() }
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">results</span> = await blocks(size: <span style="color:#ff9f43">32</span>, res: scene.camera.res)
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> results.assemble(into: image)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    gcd.wait()
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> image
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff5c57">extension</span> <span style="color:#f3f99d">Block</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">func</span> <span style="color:#57c7ff">assemble</span>(into image: PixelBuffer) -&gt; PixelBuffer {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">for</span> block <span style="color:#ff6ac1">in</span> <span style="color:#ff6ac1">self</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff6ac1">for</span> x <span style="color:#ff6ac1">in</span> (<span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.x) {
</span></span><span style="display:flex;"><span>                <span style="color:#ff6ac1">for</span> y <span style="color:#ff6ac1">in</span> (<span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.y) {
</span></span><span style="display:flex;"><span>                    <span style="color:#ff5c57">let</span> (dx, dy): (<span style="color:#ff5c57">Int</span>, <span style="color:#ff5c57">Int</span>) = (
</span></span><span style="display:flex;"><span>                        x <span style="color:#ff6ac1">+</span> block.position.x,
</span></span><span style="display:flex;"><span>                        y <span style="color:#ff6ac1">+</span> block.position.y
</span></span><span style="display:flex;"><span>                    )
</span></span><span style="display:flex;"><span>                    image[dx, dy] = block.image[x, y]
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">return</span> image
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Then we create a task for each of the block and start their integration process where the ray tracing happens. Depending on the chosen resolution and block <code>size</code>, we will spawn a varying number of rendering processes to run on their own core. The <code>await</code> keyword on line 2 tells us to wait the task to be completed before returning, and the one on line 17 to wait for all of the blocks to have finished their rendering.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">blocks</span>(size: <span style="color:#ff5c57">Int</span>, res: Vec2) async -&gt; [Block] {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span>    <span style="color:#ff6ac1">return</span> await withTaskGroup(of: Block.<span style="color:#ff6ac1">self</span>) { group <span style="color:#ff6ac1">in</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span>        <span style="color:#ff6ac1">for</span> x <span style="color:#ff6ac1">in</span> <span style="color:#ff5c57">stride</span>(from: <span style="color:#ff9f43">0</span>, to: res.x, by: size) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span>            <span style="color:#ff6ac1">for</span> y <span style="color:#ff6ac1">in</span> <span style="color:#ff5c57">stride</span>(from: <span style="color:#ff9f43">0</span>, to: res.y, by: size) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span>                <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">actual</span> = Vec2(
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span>                    <span style="color:#ff5c57">min</span>(res.x <span style="color:#ff6ac1">-</span> x, size),
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span><span>                    <span style="color:#ff5c57">min</span>(res.y <span style="color:#ff6ac1">-</span> y, size)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span>                )
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span>                group.addTask {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span><span>                    <span style="color:#ff6ac1">return</span> integrate(size: actual, p: Vec2(x, y))
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span><span>                }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span><span>            }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span><span>        <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">blocks</span>: [Block] = []
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span><span>        <span style="color:#ff6ac1">for</span> await block <span style="color:#ff6ac1">in</span> group {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span><span>            blocks.append(block)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span><span>        }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span>        <span style="color:#ff6ac1">return</span> blocks
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span><span>    }
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span><span>}
</span></span></code></pre></div><p>Finally, we can implement our own integration methods. The most simple version of that is a Monte-Carlo estimation that computes the luminance $L$ with a unidirectional path tracing algorithm. For each pixel $(x, y)$ in the block, we will cast $n$ rays of light and average their total contributions by the number of samples $n$.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">func</span> <span style="color:#57c7ff">integrate</span>(size: Vec2, p: Vec2, samples n: <span style="color:#ff5c57">Int</span> = <span style="color:#ff9f43">5</span>) -&gt; Block {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">img</span> = PixelBuffer(width: size.x, height: size.y)
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">block</span> = Block(position: Vec2(x, y), size: size, image: img)
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">for</span> lx <span style="color:#ff6ac1">in</span> <span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.x {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">for</span> ly <span style="color:#ff6ac1">in</span> <span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> block.size.y {
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">x</span> = lx <span style="color:#ff6ac1">+</span> block.position.x
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">y</span> = ly <span style="color:#ff6ac1">+</span> block.position.y
</span></span><span style="display:flex;"><span>            <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">avg</span> = Color()
</span></span><span style="display:flex;"><span>            <span style="color:#ff6ac1">for</span> <span style="color:#ff6ac1">_</span> <span style="color:#ff6ac1">in</span> (<span style="color:#ff9f43">0</span> ..<span style="color:#ff6ac1">&lt;</span> n) {
</span></span><span style="display:flex;"><span>                <span style="color:#78787e">// Anti aliasing with a uniform noise (0 ... 1)</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">pixel</span> = Vec2(x, y) <span style="color:#ff6ac1">+</span> rng.next2()
</span></span><span style="display:flex;"><span>                avg <span style="color:#ff6ac1">+=</span> li(pixel: pixel) <span style="color:#78787e">// Compute path luminance</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            img[lx, ly] = avg <span style="color:#ff6ac1">/</span> <span style="color:#ff5c57">Float</span>(n)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    block.image = img
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> block
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 class="heading" id="materials">
  Materials
  <a class="anchor" href="#materials">#</a>
</h2>
<p>Whenever light collides with a surface, it will scatter differently based on the physical properties of that surface. For example, diffuse surfaces will reflect the light equally in all possible directions. On the other hand, shiny surfaces like metal or plastic will mainly reflect the light in the direction of a specular lobe. Perfectly specular surfaces will typically have only one possible reflection direction.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 1996; --h: 503;">
        <img loading="lazy" alt="light-scattering" src="/projects/swifttracer/images/scattering.png" width="1996" height="503">
    </div>

    
</figure>
</p>
<p>SwiftTracer currently implements 4 base materials, which use their own distribution functions to support light scattering. On top of these, it is possible to blend them with a linear combination of two different materials. The strenght of the blend can be defined by an <code>alpha</code> parameter.</p>

<div class="table-outer">
    <table>
        <thead>
            <tr>
                <th style="text-align: center">Diffuse</th>
                <th style="text-align: center">Smooth metal</th>
                <th style="text-align: center">Rough metal</th>
                <th style="text-align: center">Glass</th>
                <th style="text-align: center">Blend</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="diffuse" src="/projects/swifttracer/images/diffuse.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="metal" src="/projects/swifttracer/images/metal.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="rough metal" src="/projects/swifttracer/images/metal-rough.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="glass" src="/projects/swifttracer/images/glass.png" width="512" height="512">
    </div>

    
</figure>
</td>
                <td style="text-align: center">











<figure class="">

    <div class="img-container" style="--w: 512; --h: 512;">
        <img loading="lazy" alt="glass" src="/projects/swifttracer/images/blend.png" width="512" height="512">
    </div>

    
</figure>
</td>
            </tr>
        </tbody>
    </table>
</div><h2 class="heading" id="geometry">
  Geometry
  <a class="anchor" href="#geometry">#</a>
</h2>
<p>While any numbers of geometry like cylinders, disks, spheres could have been implemented, SwiftTracer supports only a few primitives, with a bigger emphasis on meshes and triangles. For light sources or quick tests, it can be convenient to have simple shapes available, so <code>Quad</code> and <code>Sphere</code> were also added to that end.</p>
<h3 class="heading" id="mesh">
  Mesh
  <a class="anchor" href="#mesh">#</a>
</h3>
<p>The only mesh format supported at the moment is wavefront (obj). To drive the parsing and loading process, I ported over to <a href="https://github.com/Prismik/SwiftWavefront">SwiftWavefront</a> the most basic parts of <a href="https://github.com/tinyobjloader/tinyobjloader">TinyObj</a>, a very popular C++ implementation. SwiftWavefront can be consummed as a swift package and offers ready to use meshes with vertices, normals and texture coordinates.</p>
<p>











<figure class="">

    <div class="img-container" style="--w: 2068; --h: 962;">
        <img loading="lazy" alt="SwiftWavefrontApi" src="/projects/swifttracer/images/swiftwavefront.png" width="2068" height="962">
    </div>

    
</figure>
</p>
<p>The conversion to triangles can be done by loading the obj and then assigning the data to triangles by using their own transform matrix.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">let</span> <span style="color:#ff5c57">obj</span> = Wavefront(filename: filename, encoding: .utf8)
</span></span><span style="display:flex;"><span>positions = <span style="color:#ff5c57">stride</span>(from: <span style="color:#ff9f43">0</span>, through: obj.vertices.<span style="color:#ff5c57">count</span> <span style="color:#ff6ac1">-</span> <span style="color:#ff9f43">1</span>, by: <span style="color:#ff9f43">3</span>).<span style="color:#ff5c57">map</span> { i <span style="color:#ff6ac1">in</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">x</span> = wavefront.vertices[i]
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">y</span> = wavefront.vertices[i <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">z</span> = wavefront.vertices[i <span style="color:#ff6ac1">+</span> <span style="color:#ff9f43">2</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">return</span> transform.point(Vec3(x, y, z))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Triangle intersection uses the <a href="https://dl.acm.org/doi/10.1145/1198555.1198746">MÃ¶llerâ€“Trumbore ray-triangle intersection algorithm</a>. Vertices and normals are currently supported, but tangents will be added at a later time when I implement microfacets.</p>
<h2 class="heading" id="loading-generic-objects">
  Loading generic objects
  <a class="anchor" href="#loading-generic-objects">#</a>
</h2>
<p>The loading of my scenes relies heavily on the <code>Codable</code> protocol which has been available for a while, as well as a system of generic <code>Any</code> types that can be converted to their concrete implementation. You can feed a JSON to SwiftTracer and it will gracefully do the conversion from the boxed type to the concrete implementation.</p>
<p>To illustrate that process, imagine you have a generic type you want to decode like <code>Material</code>. It has several implementations which all require different properties to be decoded. We start with <code>AnyMaterial</code>, a box type definition that encapsulates the types it wants to decode and a generic <code>wrapped</code> entity. It also has some high level coding keys shared by all of the <code>Material</code> implementations.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">struct</span> <span style="color:#f3f99d">AnyMaterial</span>: Decodable {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">enum</span> <span style="color:#f3f99d">TypeIdentifier</span>: <span style="color:#ff5c57">String</span>, Decodable {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> diffuse
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> metal
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> dielectric
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> blend
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">enum</span> <span style="color:#f3f99d">CodingKeys</span>: <span style="color:#ff5c57">String</span>, CodingKey {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> type
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> name
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> params
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">name</span>: <span style="color:#ff5c57">String</span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">type</span>: TypeIdentifier
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">private</span>(<span style="color:#ff6ac1">set</span>) <span style="color:#ff5c57">var</span> <span style="color:#ff5c57">wrapped</span>: Material
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now let&rsquo;s say we have a concrete implementation of that <code>Material</code> type called <code>Diffuse</code>. It needs an <code>albedo</code> property of the <code>Texture</code> type. Other materials don&rsquo;t need that property so we define it here.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff6ac1">final</span> <span style="color:#ff5c57">class</span> <span style="color:#f3f99d">Diffuse</span>: Material {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">enum</span> <span style="color:#f3f99d">CodingKeys</span>: <span style="color:#ff5c57">String</span>, CodingKey {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">case</span> albedo
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">texture</span>: Texture
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">init</span>(texture: Texture) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">self</span>.texture = texture
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#78787e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can now decode that type in <code>AnyMaterial</code> and store it in the wrapped property without worrying about it&rsquo;s concrete implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">init</span>(from decoder: Decoder) <span style="color:#ff6ac1">throws</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">container</span> = <span style="color:#ff6ac1">try</span> decoder.container(keyedBy: CodingKeys.<span style="color:#ff6ac1">self</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">self</span>.type = <span style="color:#ff6ac1">try</span> container.decode(TypeIdentifier.<span style="color:#ff6ac1">self</span>, forKey: .type)
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">self</span>.name = <span style="color:#ff6ac1">try</span> container.decodeIfPresent(<span style="color:#ff5c57">String</span>.<span style="color:#ff6ac1">self</span>, forKey: .name) ?? <span style="color:#5af78e">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">switch</span> type {
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">case</span> .diffuse:
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">params</span> = <span style="color:#ff6ac1">try</span> container.nestedContainer(keyedBy: Diffuse.CodingKeys.<span style="color:#ff6ac1">self</span>, forKey: .params)
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">albedo</span> = <span style="color:#ff6ac1">try</span> params.decodeIfPresent(Texture.<span style="color:#ff6ac1">self</span>, forKey: .albedo) ?? <span style="color:#ff9f43">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">self</span>.wrapped = Diffuse(texture: texture)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using this is now quite simple; we need a properly formatted JSON</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff6ac1">&#34;materials&#34;</span>: [{
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">&#34;name&#34;</span>: <span style="color:#5af78e">&#34;red-tint&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">&#34;type&#34;</span>: <span style="color:#5af78e">&#34;diffuse&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ff6ac1">&#34;params&#34;</span>: { <span style="color:#ff6ac1">&#34;albedo&#34;</span>: [<span style="color:#ff9f43">0.95</span>, <span style="color:#ff9f43">0.1</span>, <span style="color:#ff9f43">0.1</span>] }
</span></span><span style="display:flex;"><span>    }]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>which can be decoded it in the root container.</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#ff5c57">init</span>(from decoder: Decoder) <span style="color:#ff6ac1">throws</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">container</span> = <span style="color:#ff6ac1">try</span> decoder.container(keyedBy: CodingKeys.<span style="color:#ff6ac1">self</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">generic</span> = <span style="color:#ff6ac1">try</span> container.decode([AnyMaterial].<span style="color:#ff6ac1">self</span>, forKey: .materials)
</span></span><span style="display:flex;"><span>    <span style="color:#ff5c57">let</span> <span style="color:#ff5c57">materials</span> = generic.<span style="color:#ff5c57">reduce</span>(into: [<span style="color:#ff5c57">String</span>: Material]()) {
</span></span><span style="display:flex;"><span>        <span style="color:#ff5c57">$0</span>[<span style="color:#ff5c57">$1</span>.name] = <span style="color:#ff5c57">$1</span>.wrapped
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
  </article>

  

  

  
  

  

  

  
  <div class="back-to-top">
    <a href="#top">
      back to top
    </a>
  </div>
  

</div>


    </main>
  </div>

  
  





    




  <footer>
    

    
    





    




    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  
  <link rel="stylesheet" 
  href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  
<script defer 
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js"></script>

<script defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  });
</script>
  
</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
